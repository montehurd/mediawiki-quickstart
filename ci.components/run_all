#!/bin/bash
set -euo pipefail

RESULTS_DIR="${RESULTS_DIR:-./ci.components/runs}"
source "./ci.components/run_for_component"
source "./ci.components/run_for_core"

separator="-----------------------------------------------------------------"

list_all_components() {
  find extensions skins -mindepth 1 -maxdepth 1 -type d | sort
}

component_slug() {
  local s="${1#./}"
  s="${s%/}"
  s="${s// /-}"
  s="${s//\//-}"
  printf '%s' "$s"
}

# convert ANSI to HTML
convert_to_html() {
  local ansi_file="$1"

  if command -v alpine_ansi2html &>/dev/null; then
    alpine_ansi2html <"${ansi_file}" >"${ansi_file}.html"
  else
    if [[ "${VERBOSE:-0}" != "0" ]]; then
      echo "alpine_ansi2html not found; skipping HTML conversion for ${ansi_file}" >&2
    fi
    return 0
  fi
}

run_all() {
  local ts
  ts="$(date -u +%s)"

  local run_dir="${RESULTS_DIR}/${ts}"
  local results_dir="${run_dir}/results"
  mkdir -p "${results_dir}"

  local aggregate_log="${run_dir}/${ts}.logs.ansi"
  local yaml_file="${run_dir}/${ts}.yaml"
  # Open aggregate log
  exec 3>"${aggregate_log}"

  local yaml_content="timestamp: ${ts}
commit:
  hash: $(git rev-parse --short HEAD)
  message: $(git log -1 --format='%s')"

  # ----- Core -----
  local core_dir="${results_dir}/core"
  mkdir -p "${core_dir}"
  local core_log="${core_dir}/logs.ansi"

  # Run duplicated to both aggregate and core logs
  local core_results
  core_results="$(run_for_core 3> >(tee -a "${aggregate_log}" >"${core_log}"))"

  yaml_content+=$'\ncore:'"${core_results}"$'\ncomponents:'

  # Collect all log files for HTML conversion (core + components only)
  local -a log_files=("${core_log}")

  # Components
  local component
  for component in $(list_all_components); do
    local slug comp_dir comp_log comp_yaml
    slug="$(component_slug "${component}")"
    comp_dir="${results_dir}/${slug}"
    mkdir -p "${comp_dir}"
    comp_log="${comp_dir}/logs.ansi"

    comp_yaml="$(run_for_component "${component}" 3> >(tee -a "${aggregate_log}" >"${comp_log}"))"
    yaml_content+="${comp_yaml}"

    log_files+=("${comp_log}")
  done

  # Close aggregate
  exec 3>&-

  # keep the aggregate .logs.ansi file but do NOT generate HTML for it

  # Save YAML
  printf '%s\n' "${yaml_content}" >"${yaml_file}"

  # Convert logs to HTML (core + components only) in parallel
  # Limit concurrency so we don't spawn too many processes.
  local max_procs="${MAX_HTML_PROCS:-4}"
  local i=0

  for f in "${log_files[@]}"; do
    # Throttle number of concurrent jobs
    (( i = i % max_procs ))
    (( i++ == 0 )) && wait

    convert_to_html "$f" &
  done
  # Wait for any remaining conversions to finish
  wait

  printf 'Run complete: %s\n' "${run_dir}"
}

if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then
  run_all "$@"
fi
